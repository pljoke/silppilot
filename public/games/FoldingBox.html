<!DOCTYPE html>
<html lang="en">
<head>
    <base target="_top">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Folding Box</title>
    <style>
        :root {
            --primary-color: #722F37;
            --secondary-color: #8B4513;
            --bg-color-light: #FAF7F2;
            --bg-color-dark: #F5F2EA;
            --surface-color: #FFFEF9;
            --text-color: #3a2e2c;
            --text-color-secondary: #8B4513;
            --border-color: #E8DDD4;
            --light-text: #fff;
            --success-color: #28a745;
            --danger-color: #dc3545;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ: ‡∏´‡πâ‡∏≤‡∏° Highilight ‡πÅ‡∏•‡∏∞‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Text */
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-color-light) 0%, var(--bg-color-dark) 100%);
            color: var(--text-color);
            padding: 20px;
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header {
            background: rgba(255, 253, 250, 0.95);
            padding: 15px 20px;
            box-shadow: 0 2px 10px rgba(139, 69, 19, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1001;
            border-bottom: 2px solid var(--secondary-color);
        }

            .header h1 {
                color: var(--primary-color);
                font-size: 24px;
            }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .container {
            width: 100%;
            padding-top: 80px;
        }

        .test-container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--surface-color);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(139, 69, 19, 0.1);
            border: 1px solid var(--border-color);
            text-align: center;
        }

        h1, h2, h3 {
            color: var(--primary-color);
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        p {
            color: var(--text-color-secondary);
            margin-bottom: 1.5rem;
        }

        .game-layout {
            display: flex;
            gap: 20px;
            text-align: left;
        }

        .question-sidebar {
            flex: 0 0 240px;
            background: var(--bg-color-dark);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            align-self: flex-start;
        }

        .game-content {
            flex-grow: 1;
            position: relative;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-color-dark);
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .timer {
            font-size: 1.5rem;
            color: var(--primary-color);
        }

            .timer.danger {
                color: var(--danger-color);
                animation: pulse 1s infinite;
            }

        @keyframes pulse {
            50% {
                opacity: 0.6;
            }
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 8px;
        }

        .question-nav-btn {
            width: 100%;
            aspect-ratio: 1;
            background-color: var(--bg-color-light);
            color: var(--text-color-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

            .question-nav-btn.answered {
                background-color: var(--primary-color);
                color: var(--light-text);
            }

            .question-nav-btn.current {
                background-color: var(--secondary-color);
                color: var(--light-text);
                transform: scale(1.1);
            }

            .question-nav-btn.correct {
                background-color: var(--success-color);
                color: white;
            }

            .question-nav-btn.incorrect {
                background-color: var(--danger-color);
                color: white;
            }

        .legend {
            margin-top: 15px;
            text-align: left;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            margin-right: 10px;
            border: 1px solid #ccc;
        }

        .question-section {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: var(--bg-color-dark);
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(4, 40px);
            grid-template-rows: repeat(4, 40px);
            gap: 2px;
            justify-content: center;
        }

        .pattern-cell {
            width: 40px;
            height: 40px;
            border: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 24px;
            background-color: var(--surface-color);
            color: var(--primary-color);
        }

            .pattern-cell.empty {
                border: none;
                background: transparent;
            }

        .cube-container {
            perspective: 1000px;
            display: inline-block;
        }

        .cube {
            position: relative;
            width: 80px;
            height: 80px;
            transform-style: preserve-3d;
            transform: rotateX(-25deg) rotateY(45deg);
        }

        .cube-face {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 32px;
            opacity: 1.0;
            color: var(--primary-color);
            backface-visibility: hidden;
        }

            .cube-face.front {
                transform: translateZ(40px);
                background-color: #F5F2EA;
            }

            .cube-face.left {
                transform: rotateY(-90deg) translateZ(40px);
                background-color: #E8DDD4;
            }

            .cube-face.top {
                transform: rotateX(90deg) translateZ(40px);
                background-color: #D4C7B8;
            }

        .choices-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .choice-button {
            padding: 1rem;
            border: 3px solid var(--border-color);
            background-color: #FAF7F2;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }

            /* [‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç] ‡πÉ‡∏™‡πà media query ‡∏Ñ‡∏£‡∏≠‡∏ö‡πÑ‡∏ß‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î Sticky Hover ‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ */
            @media (hover: hover) {
                .choice-button:hover:not(.disabled) {
                    background-color: #F0EBE3;
                    border-color: var(--primary-color);
                    transform: translateY(-2px);
                }
            }
            /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ß‡∏£‡πå ‡πÉ‡∏´‡πâ‡∏Å‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏ó‡∏±‡∏ô‡∏ó‡∏µ */
            .choice-button:active {
                background-color: #F0EBE3;
                border-color: var(--primary-color);
            }

            .choice-button.selected {
                border-color: var(--secondary-color);
                background-color: var(--border-color); /* ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ */
                box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1); /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏≤‡∏î‡πâ‡∏≤‡∏ô‡πÉ‡∏ô‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏°‡∏µ‡∏°‡∏¥‡∏ï‡∏¥ */
            }

            .choice-button.disabled {
                cursor: not-allowed;
                pointer-events: none;
            }

            .choice-button.correct {
                border-color: var(--success-color) !important;
                background-color: #d4edda !important;
            }

            .choice-button.incorrect.user-selected {
                border-color: var(--danger-color) !important;
                background-color: #f8d7da !important;
            }

            .choice-button.incorrect:not(.user-selected) {
                opacity: 0.6;
            }

            .choice-button.user-selected {
                box-shadow: 0 0 0 3px var(--secondary-color) inset;
            }

        .navigation-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

            .navigation-controls.center {
                justify-content: center;
            }

        .btn {
            font-size: 1rem;
            padding: 12px 28px;
            cursor: pointer;
            border-radius: 25px;
            border: none;
            font-weight: bold;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }

            .btn:hover:not(:disabled) {
                transform: translateY(-2px);
                opacity: 0.9;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            }

            .btn:disabled {
                background-color: #ccc !important;
                cursor: not-allowed;
                transform: none;
                box-shadow: none;
            }

        .btn-primary {
            background: var(--primary-color);
            color: var(--light-text);
        }

        .btn-secondary {
            background: var(--secondary-color);
            color: var(--light-text);
        }

        .btn-success {
            background: var(--success-color);
            color: var(--light-text);
        }

        .outline-btn {
            background-color: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }

            .outline-btn:hover {
                background-color: var(--primary-color);
                color: white;
            }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 25px;
            align-items: center;
        }

        .results-container .action-buttons {
            flex-direction: row;
            flex-wrap: wrap;
        }

        .start-screen-card .action-buttons .btn,
        .difficulty-screen-card .action-buttons .btn {
            width: 100%;
            max-width: 300px;
            text-align: center;
            font-size: 1.1rem;
            padding: 14px;
        }

        .hidden {
            display: none !important;
        }

        .start-screen-card, .tutorial-screen-card {
            max-width: 600px;
        }

        .modal {
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
        }

            .modal.active {
                display: flex;
            }

        .modal-content {
            background: var(--surface-color);
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 450px;
            text-align: center;
        }

        .results-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .result-summary {
            text-align: left;
            background: var(--bg-color-dark);
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            max-width: 450px;
            margin-left: auto;
            margin-right: auto;
        }

            .result-summary p {
                font-size: 1.25rem;
                margin: 12px 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

                .result-summary p strong {
                    font-size: 1.5rem;
                    color: var(--primary-color);
                }

        .result-comparison {
            display: flex;
            gap: 2rem;
        }

        .result-column {
            flex: 1;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-color-dark);
            text-align: left;
        }

            .result-column h3 {
                color: var(--text-color-secondary);
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 0.5rem;
                margin-bottom: 1rem;
                text-align: center;
            }

        .result-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap-x: 2rem;
            gap-y: 1.25rem;
            align-items: center;
        }

            .result-grid span:nth-child(odd) {
                font-weight: 600;
            }

            .result-grid span:nth-child(even) {
                font-weight: bold;
                text-align: right;
            }

        .results-container .action-buttons {
            flex-direction: row;
            justify-content: center;
            flex-wrap: wrap;
        }

        .loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(250, 247, 242, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loader-spinner {
            border: 8px solid var(--border-color);
            border-top: 8px solid var(--primary-color);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .practice-mode-active .question-sidebar {
            display: none;
        }

        .tutorial-example {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            background: var(--bg-color-dark);
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        /* --- START: Styles for Interactive Review Cube --- */
        /* --- START: Absolute Positioning for Buttons --- */
        .review-cube-area {
            /* Keep existing styles: margin, padding, background, border-radius, border */
            margin-top: 2rem;
            margin-bottom: 2rem;
            padding: 20px;
            background: var(--bg-color-dark);
            border-radius: 10px;
            border: 1px solid var(--border-color);
            text-align: center;
            /* position: relative; */ /* Removed grid, keep text-align center */
        }

            .review-cube-area h3 {
                /* Keep existing styles */
                margin-bottom: 1.5rem;
                color: var(--text-color-secondary);
            }

        .cube-control-wrapper {
            position: relative; /* Make this the reference for absolute buttons */
            display: inline-block; /* Allow centering using text-align on parent */
            width: 200px; /* Approximate width needed for cube + buttons */
            height: 200px; /* Approximate height needed */
            margin: 0 auto; /* Center the wrapper */
        }

        .cube-container-interactive {
            /* Position the cube container in the center of the wrapper */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center trick */
            perspective: 1200px;
            margin-bottom: 0; /* No extra margin needed */
        }

        .interactive-cube {
            width: 100px;
            height: 100px;
            position: relative;
            transform-style: preserve-3d;
            /* ‡πÄ‡∏≠‡∏≤ transition ‡∏≠‡∏≠‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏∏‡∏ô‡∏ï‡∏≤‡∏°‡∏°‡∏∑‡∏≠‡∏ó‡∏±‡∏ô‡∏ó‡∏µ */
            /* transition: transform 0.5s ease-out; */
            transform: rotateX(-25deg) rotateY(45deg);
            cursor: grab; /* ‡∏£‡∏π‡∏õ‡∏°‡∏∑‡∏≠‡πÅ‡∏ö */
        }

            .interactive-cube:active {
                cursor: grabbing; /* ‡∏£‡∏π‡∏õ‡∏°‡∏∑‡∏≠‡∏Å‡∏≥‡πÄ‡∏ß‡∏•‡∏≤‡∏Ñ‡∏•‡∏¥‡∏Å */
            }

            .interactive-cube .face {
                /* Keep existing face styles */
                position: absolute;
                width: 100px;
                height: 100px;
                border: 2px solid var(--primary-color);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 40px;
                font-weight: bold;
                color: var(--primary-color);
                background-color: rgba(255, 254, 249, 0.85);
                backface-visibility: hidden;
                user-select: none;
            }
                /* Keep face positioning styles */
                .interactive-cube .face.front {
                    transform: rotateY( 0deg) translateZ(50px);
                    background-color: #F5F2EA;
                }

                .interactive-cube .face.back {
                    transform: rotateY(180deg) translateZ(50px);
                    background-color: #E8DDD4;
                }

                .interactive-cube .face.left {
                    transform: rotateY(-90deg) translateZ(50px);
                    background-color: #E8DDD4;
                }

                .interactive-cube .face.right {
                    transform: rotateY( 90deg) translateZ(50px);
                    background-color: #E8DDD4;
                }

                .interactive-cube .face.top {
                    transform: rotateX( 90deg) translateZ(50px);
                    background-color: #D4C7B8;
                }

                .interactive-cube .face.bottom {
                    transform: rotateX(-90deg) translateZ(50px);
                    background-color: #D4C7B8;
                }


        /* General button style (keep mostly the same) */
        .rot-btn {
            position: absolute; /* Position relative to wrapper */
            font-size: 1.5rem;
            width: 45px;
            height: 45px;
            cursor: pointer;
            border: 2px solid var(--secondary-color);
            background-color: var(--surface-color);
            color: var(--secondary-color);
            border-radius: 50%;
            transition: background-color 0.2s, color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            user-select: none;
            z-index: 10; /* Ensure buttons are above cube visually */
        }

            .rot-btn:hover {
                background-color: var(--secondary-color);
                color: var(--surface-color);
            }

        /* Specific positions using top, left, bottom, right */
        .rot-up-abs {
            top: 0;
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
        }

        .rot-down-abs {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
        }

        .rot-left-abs {
            top: 50%;
            left: 0;
            transform: translateY(-50%); /* Center vertically */
        }

        .rot-right-abs {
            top: 50%;
            right: 0;
            transform: translateY(-50%); /* Center vertically */
        }

        .rot-zanti-abs {
            bottom: 0;
            left: 0;
            /* transform: translate(-10%, 10%); */ /* Adjust slightly if needed */
        }

        .rot-zclock-abs {
            bottom: 0;
            right: 0;
            /* transform: translate(10%, 10%); */ /* Adjust slightly if needed */
        }
        /* --- END: Absolute Positioning --- */

        /* Remove the old flexbox div styling if it exists */

        /* Assign buttons to grid areas */
        #rotateUpBtn {
            grid-area: up;
        }

        #rotateDownBtn {
            grid-area: down;
        }

        #rotateLeftBtn {
            grid-area: left;
        }

        #rotateRightBtn {
            grid-area: right;
        }

        /* Keep button styles the same */

        /* --- START: Styles for Rotation Controls --- */
        /* --- START: Styles for Rotation Controls (Revised Grid) --- */
        .rotation-controls {
            display: grid;
            grid-template-columns: repeat(3, 45px); /* Fixed size columns */
            grid-template-rows: repeat(3, 45px); /* Fixed size rows */
            gap: 10px;
            justify-content: center; /* Center the grid itself */
            align-items: center; /* Center items in cells */
            width: auto; /* Allow width to adjust */
            margin: 1.5rem auto 0 auto;
        }

        /* Assign buttons to specific grid cells (row / column) */
        #rotateUpBtn {
            grid-row: 1;
            grid-column: 2;
        }

        #rotateLeftBtn {
            grid-row: 2;
            grid-column: 1;
        }

        #rotateRightBtn {
            grid-row: 2;
            grid-column: 3;
        }

        #rotateZAntiClockwiseBtn {
            grid-row: 3;
            grid-column: 1;
        }

        #rotateDownBtn {
            grid-row: 3;
            grid-column: 2;
        }

        #rotateZClockwiseBtn {
            grid-row: 3;
            grid-column: 3;
        }


        .rotation-controls button {
            /* Keep existing button styles (font-size, width, height, border, etc.) */
            font-size: 1.5rem;
            width: 45px;
            height: 45px;
            cursor: pointer;
            border: 2px solid var(--secondary-color);
            background-color: var(--surface-color);
            color: var(--secondary-color);
            border-radius: 50%;
            transition: background-color 0.2s, color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* Remove padding if any */
        }

            .rotation-controls button:hover {
                background-color: var(--secondary-color);
                color: var(--surface-color);
            }
        /* Remove the specific > div rule if it exists */
        /* .rotation-controls > div { ... } */
        /* --- END: Styles for Rotation Controls (Revised Grid) --- */

        /* Optional: Adjust review-cube-area if needed */
        .review-cube-area {
            text-align: center; /* Ensure contents are centered */
        }

        .cube-container-interactive {
            margin-bottom: 1.5rem; /* Ensure space below cube */
        }
        /* --- END: Styles for Interactive Review Cube --- */
        .pattern-cell {
            /* ... existing styles ... */
            user-select: none; /* Add this */
        }

        .cube-face { /* This applies to choice cubes */
            /* ... existing styles ... */
            user-select: none; /* Add this */
        }

        .interactive-cube .face { /* This applies to the interactive review cube */
        }
        /* Optional: Add to the containers as well for extra safety */
        .cube-container, .cube-container-interactive {
            user-select: none;
        }

        /* --- START: ADDED FOR HELL MODE --- */
        .choice-button.selected {
            border-color: var(--secondary-color);
            background-color: #F0EBE3; /* ‡πÉ‡∏ä‡πâ‡∏™‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ */
            box-shadow: inset 0 3px 6px rgba(0, 0, 0, 0.15); /* ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏≤‡∏î‡πâ‡∏≤‡∏ô‡πÉ‡∏ô‡πÉ‡∏´‡πâ‡∏î‡∏π‡∏°‡∏µ‡∏°‡∏¥‡∏ï‡∏¥ */
        }

        /* --- MOBILE & TABLET OPTIMIZATION (FIXED ALL ISSUES) --- */
        @media (max-width: 992px) {
            /* 1. Hamburger & Header */
            .hamburger-btn { display: block; }
            .header h1 { font-size: 1.1rem; } 
            
            /* Sidebar */
            .question-sidebar {
                position: fixed;
                top: 70px; 
                left: -280px;
                width: 260px;
                height: calc(100% - 70px);
                z-index: 1000;
                transition: left 0.3s ease;
                box-shadow: 2px 0 5px rgba(0,0,0,0.2);
                margin: 0;
                display: block !important; 
                background: var(--bg-color-dark); 
            }
            .question-sidebar.active { left: 0; }
            .sidebar-overlay {
                display: none;
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); z-index: 999;
            }
            .sidebar-overlay.active { display: block; }

            /* 2. [‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠ 2] ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î Font ‡∏õ‡∏∏‡πà‡∏°‡πÅ‡∏•‡∏∞ Text */
            body { font-size: 0.9rem !important; }
            .btn { 
                font-size: 0.85rem !important; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏õ‡∏∏‡πà‡∏° */
                padding: 10px 15px !important; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡πâ‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏õ‡∏∏‡πà‡∏° */
            }
            h1 { font-size: 1.4rem; }
            h2 { font-size: 1.2rem; }
            h3 { font-size: 1rem; }
            
            /* 3. [‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠ 1] ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÇ‡∏à‡∏ó‡∏¢‡πå (Pattern) */
            .pattern-cell {
                width: 28px !important; /* ‡∏•‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏ä‡πà‡∏≠‡∏á‡∏•‡∏á‡∏≠‡∏µ‡∏Å‡∏ô‡∏¥‡∏î */
                height: 28px !important;
                font-size: 16px !important;
            }
            .pattern-grid {
                grid-template-columns: repeat(4, 28px) !important;
                grid-template-rows: repeat(4, 28px) !important;
                gap: 1px !important; /* ‡∏•‡∏î‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ä‡πà‡∏≠‡∏á */
            }
            /* ‡∏•‡∏î padding ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πà‡∏≠‡∏á‡πÇ‡∏à‡∏ó‡∏¢‡πå */
            .question-section {
                padding: 10px !important;
                margin-bottom: 10px !important;
            }
            /* ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á How to Play */
            #howToPlayScreen .tutorial-example {
                transform: scale(0.65);
                transform-origin: center center;
                margin: -20px 0 !important; /* ‡∏î‡∏∂‡∏á‡πÉ‡∏´‡πâ‡∏ä‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô */
            }
            #howToPlayScreen {
                padding: 10px !important;
            }
            
            /* 4. Hell Mode Choice Size */
            .choices-container.hell-review-mode {
                gap: 4px !important;
                padding: 0 2px;
                margin-top: 5px !important;
            }
            .choices-container.hell-review-mode .choice-button {
                height: 70px !important; 
            }
            .choices-container.hell-review-mode .choice-button .cube-container {
                transform: scale(0.45) !important; 
            }

            /* 5. [‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠ 3] Results Screen Layout (‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ö‡∏ô-‡∏•‡πà‡∏≤‡∏á) */
            .result-comparison {
                flex-direction: column !important; /* ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á */
                gap: 15px !important;
            }
            .result-column {
                width: 100% !important; /* ‡πÄ‡∏ï‡πá‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á */
                margin-bottom: 10px;
            }
            /* ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤ Results ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏™‡∏ß‡∏¢ */
            .results-container .action-buttons {
                flex-direction: column !important;
                gap: 10px !important;
            }
            .results-container .action-buttons .btn {
                width: 100% !important; /* ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏ï‡πá‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á */
                max-width: none !important;
            }

            /* Review Cube Area */
            .review-cube-area {
                padding: 5px !important;
                margin: 5px 0 !important;
            }
            .review-cube-area .cube-control-wrapper {
                height: 110px !important;
                transform: scale(0.8);
            }
            .cube-container-interactive, .interactive-cube { touch-action: none; }
        }

        /* --- NEW STYLES: Header & Mobile & Hell Mode --- */

        /* 1. Timer in Header */
        .header-center {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
        }

        /* 2. Hamburger Menu (Mobile Only) */
        .hamburger-btn {
            display: none;
            background: none;
            border: none;
            font-size: 24px;
            color: var(--primary-color);
            cursor: pointer;
            margin-right: 15px;
        }

        /* 4. Responsive Sidebar (Mobile/Tablet) & Mobile Fit Fix */
        @media (max-width: 992px) {
            .hamburger-btn {
                display: block;
            }

            .header h1 {
                font-size: 1.2rem;
            }

            /* ‡∏ã‡πà‡∏≠‡∏ô Sidebar ‡∏õ‡∏Å‡∏ï‡∏¥ */
            .question-sidebar {
                position: fixed;
                top: 70px; /* ‡πÉ‡∏ï‡πâ Header */
                left: -280px; /* ‡∏ã‡πà‡∏≠‡∏ô‡∏ó‡∏≤‡∏á‡∏ã‡πâ‡∏≤‡∏¢ */
                width: 260px;
                height: calc(100% - 70px);
                z-index: 1000;
                transition: left 0.3s ease;
                box-shadow: 2px 0 5px rgba(0,0,0,0.2);
                margin: 0;
                /* [‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠ 3] ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡πÑ‡∏î‡πâ ‡πÅ‡∏°‡πâ‡πÄ‡∏õ‡πá‡∏ô Practice Mode) */
                display: block !important;
            }

                .question-sidebar.active {
                    left: 0; /* ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏≠‡∏≠‡∏Å‡∏°‡∏≤ */
                }

            /* Overlay ‡∏â‡∏≤‡∏Å‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏ô‡∏π */
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 999;
            }

                .sidebar-overlay.active {
                    display: block;
                }

            /* [‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠ 2] ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î Choice ‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠‡πÉ‡∏´‡πâ Fit ‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏î‡∏µ‡∏¢‡∏ß */
            .choices-container {
                /* ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏õ‡∏∏‡πà‡∏° */
                gap: 8px !important;
                margin-top: 10px !important;
                /* ‡∏õ‡∏£‡∏±‡∏ö Grid ‡πÉ‡∏´‡πâ‡∏ä‡∏¥‡∏î‡∏Ç‡∏≠‡∏ö */
                padding-left: 5px;
                padding-right: 5px;
            }

            .choice-button {
                /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 80px (‡∏à‡∏≤‡∏Å‡πÄ‡∏î‡∏¥‡∏° 90px ‡∏´‡∏£‡∏∑‡∏≠ auto) */
                height: 80px !important;
                min-height: 0 !important;
                padding: 0 !important;
            }

                /* ‡∏¢‡πà‡∏≠‡∏•‡∏π‡∏Å‡πÄ‡∏ï‡πã‡∏≤‡∏•‡∏á‡∏≠‡∏µ‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÉ‡∏™‡πà‡πÉ‡∏ô‡∏õ‡∏∏‡πà‡∏° 80px ‡πÑ‡∏î‡πâ */
                .choice-button .cube-container {
                    transform: scale(0.55) !important;
                    transform-origin: center center !important;
                    margin: 0 !important;
                    /* ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏Å‡∏•‡πà‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏î‡∏±‡∏ô‡∏ó‡∏µ‡πà */
                    width: 80px !important;
                    height: 80px !important;
                    display: flex !important;
                    justify-content: center;
                    align-items: center;
                }

            /* ‡∏ã‡πà‡∏≠‡∏ô‡∏™‡πà‡∏ß‡∏ô Practice Review Cube (‡πÄ‡∏â‡∏•‡∏¢) ‡∏ñ‡πâ‡∏≤‡∏°‡∏±‡∏ô‡∏Å‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î‡πÜ */
            .review-cube-area {
                padding: 5px !important;
                margin-top: 10px !important;
                margin-bottom: 10px !important;
            }

                .review-cube-area .cube-control-wrapper {
                    height: 120px !important; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏â‡∏•‡∏¢ */
                    transform: scale(0.8);
                }
        }

        /* --- [FIX 4] Header Timer New Style (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô SCN) --- */
        .header-center {
            /* ‡∏•‡∏ö class ‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏ß‡πà‡∏≤‡∏á‡πÑ‡∏ß‡πâ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡∏¢‡πâ‡∏≤‡∏¢ Timer ‡πÑ‡∏õ‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤ */
            display: none;
        }

        .header-timer {
            display: none; /* ‡∏ã‡πà‡∏≠‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥ ‡πÇ‡∏ä‡∏ß‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô‡∏™‡∏≠‡∏ö */
            font-family: 'Segoe UI', monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            background: transparent; /* ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á */
            border: none; /* ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏£‡∏≠‡∏ö */
            padding: 0;
            margin-right: 15px; /* ‡πÄ‡∏ß‡πâ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏õ‡∏∏‡πà‡∏° */
            width: 80px; /* Fix ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏Ç‡∏Ç‡∏¢‡∏±‡∏ö‡πÑ‡∏õ‡∏°‡∏≤ */
            text-align: right;
        }

            .header-timer.danger {
                color: var(--danger-color);
                animation: pulse 1s infinite;
            }

        /* --- [FIX 3] Hell Mode Layout ‡πÅ‡∏¢‡∏Å Quiz vs Review --- */

        /* Quiz Mode: Hell Mode ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ 2 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ CSS ‡πÄ‡∏û‡∏¥‡πà‡∏° ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ default ‡∏Ñ‡∏∑‡∏≠ 2) */

        /* [FIXED FINAL V3 - SAFETY FIRST] Review Mode (Hell Only) */
        .choices-container.hell-review-mode {
            /* ‡∏à‡∏±‡∏î Grid 2 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå */
            grid-template-columns: 1fr 1fr !important;
            gap: 15px !important;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

            .choices-container.hell-review-mode .choice-button {
                display: flex !important;
                justify-content: center !important;
                align-items: center !important;
                /* [‡πÅ‡∏Å‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ] ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏à‡∏≤‡∏Å 160px ‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 90px ‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏ï‡∏±‡∏ß‡∏•‡∏π‡∏Å‡πÄ‡∏ï‡πã‡∏≤ */
                height: 90px !important;
                padding: 0 !important;
                /* ‡∏Ñ‡∏á‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÑ‡∏ß‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡πà‡∏ß‡∏ô‡∏õ‡∏•‡∏≤‡∏¢‡πÅ‡∏´‡∏•‡∏°‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡πÄ‡∏ï‡πã‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡∏î */
                overflow: visible !important;
                transform: none !important;
            }

                .choices-container.hell-review-mode .choice-button .cube-container {
                    /* ‡∏¢‡πà‡∏≠‡∏•‡∏π‡∏Å‡πÄ‡∏ï‡πã‡∏≤ 80px ‡∏•‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 70% ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏ä‡πà‡∏≠‡∏á */
                    transform: scale(0.7) !important;
                    transform-origin: center center !important;
                    /* Reset ‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÜ */
                    margin: 0 !important;
                    display: block !important;
                    width: 80px !important; /* ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏î‡∏¥‡∏° */
                    height: 80px !important; /* ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏î‡∏¥‡∏° */
                    pointer-events: none; /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å‡πÇ‡∏î‡∏ô‡∏•‡∏π‡∏Å‡πÄ‡∏ï‡πã‡∏≤ */
                }

        /* ‡∏õ‡∏£‡∏±‡∏ö‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏â‡∏•‡∏¢‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πá‡∏Å‡πÅ‡∏•‡∏∞‡∏ä‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ */
        .review-area-hell-compact {
            margin-top: 10px !important;
            padding: 5px !important;
            transform: scale(0.9);
            transform-origin: top center;
        }

            .review-area-hell-compact .cube-control-wrapper {
                height: 140px !important;
            }

        /* Review Area Hell Mode: ‡∏¢‡πà‡∏≠‡∏Ç‡∏ô‡∏≤‡∏î Correctly Folded Box ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Fit ‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ */
        .review-area-hell-compact {
            margin-top: 0.5rem !important;
            margin-bottom: 0.5rem !important;
            padding: 5px !important;
            transform: scale(0.85); /* ‡∏¢‡πà‡∏≠‡∏™‡πà‡∏ß‡∏ô‡∏•‡∏á 15% */
            transform-origin: top center;
        }

            .review-area-hell-compact h3 {
                margin-bottom: 0.5rem !important;
                font-size: 1rem;
            }

            .review-area-hell-compact .cube-control-wrapper {
                height: 120px !important; /* ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á container */
            }
        /* --- KEYBOARD HINTS (Visual Indicators) --- */
        .choice-button {
            position: relative; /* ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ß‡∏≤‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ A,B,C ‡∏•‡∏≠‡∏¢‡∏≠‡∏¢‡∏π‡πà‡∏°‡∏∏‡∏°‡πÑ‡∏î‡πâ */
        }

        .key-hint {
            position: absolute;
            top: 5px;
            left: 8px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            font-weight: bold;
            color: var(--secondary-color);
            opacity: 0.6;
            pointer-events: none; /* ‡∏Å‡∏î‡∏ó‡∏∞‡∏•‡∏∏‡πÑ‡∏î‡πâ ‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏õ‡∏∏‡πà‡∏° */
            z-index: 5;
        }
        /* ‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏µ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏õ‡∏∏‡πà‡∏°‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ï‡πà‡∏≤‡∏á‡πÜ */
        .choice-button.selected .key-hint,
        .choice-button.correct .key-hint,
        .choice-button.incorrect .key-hint {
            color: var(--secondary-color); /* ‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° */
            opacity: 0.8;
        }

    </style>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-functions.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBAVwsclZj7DhBGSB05ZJ0jtEPIlCi6zGA",
            authDomain: "silp-pilot-platform.firebaseapp.com",
            projectId: "silp-pilot-platform",
            storageBucket: "silp-pilot-platform.firebasestorage.app",
            messagingSenderId: "307814159914",
            appId: "1:307814159914:web:b6b47ab4ac9d7c3816d553",
            measurementId: "G-PLWSHCRFGY"
        };
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const functions = firebase.functions();
    </script>
</head>
<body data-home-url="<?= ScriptApp.getService().getUrl() ?>">
    <div id="loader-overlay" class="loader-overlay"><div class="loader-spinner"></div></div>
    <div id="sidebarOverlay" class="sidebar-overlay"></div> <!-- ‡πÄ‡∏û‡∏¥‡πà‡∏° Overlay -->

    <div id="mainHeader" class="header">
        <div style="display:flex; align-items:center;">
            <button id="hamburgerBtn" class="hamburger-btn">‚ò∞</button>
            <h1>üì¶ Folding Box</h1>
        </div>

        <div class="header-buttons" style="display: flex; align-items: center;">
            <div id="headerTimer" class="header-timer">00:00</div>

            <button id="backToMenuBtn" class="btn btn-secondary header-btn hidden">Back</button>
            <button id="backToResultsBtn" class="btn btn-primary header-btn hidden">Back</button>
        </div>
    </div>

    <div class="container">
        <div id="app-container">
            <div id="startScreen" class="test-container start-screen-card">
                <h1>Folding Box</h1>
                <p>From the 2D pattern, identify which 3D box configuration is possible when folded.</p>
                <div class="action-buttons">
                    <button id="practiceModeBtn" class="btn btn-secondary">Practice Mode</button>
                    <button id="testModeBtn" class="btn btn-primary">Test Mode</button>
                    <button id="howToPlayBtn" class="btn outline-btn">How to Play</button>
                    <button class="btn outline-btn back-to-system-btn">Back to Main Page</button>
                </div>
            </div>

            <div id="howToPlayScreen" class="test-container tutorial-screen-card hidden">
                <h2>How to Play</h2>
                <div style="text-align: left;">
                    <p style="text-align: center;">
                        Your goal is to find which of the 3D boxes can
                        be formed from the given 2D pattern.
                    </p>
                    <div class="tutorial-example">
                        <div id="tutorial-pattern"></div>
                        <span>‚ûî</span>
                        <div id="tutorial-cube"></div>
                    </div>
                    <strong>Instructions:</strong>
                    <ul>
                        <li>Look at the 2D pattern and its symbols.</li>
                        <li>
                            Imagine folding the pattern into a cube.
                            Pay attention to which faces are opposite and which are adjacent.
                        </li>
                        <li>Choose the 3D box (A, B, C, or D) that shows a possible orientation of the faces when folded.</li>
                    </ul>
                </div>
                <div class="action-buttons" style="margin-top: 2rem;">
                    <button id="backToStartBtn" class="btn btn-primary">Back</button>
                </div>
            </div>

            <div id="difficultyScreen" class="test-container difficulty-screen-card hidden">
                <h2 id="difficultyTitle" style="font-size: 2rem;">Select Difficulty</h2>
                <div class="action-buttons">
                    <button id="easyBtn" data-difficulty="easy" class="btn btn-primary">Easy</button>
                    <button id="normalBtn" data-difficulty="normal" class="btn btn-primary">Normal</button>
                    <button id="hardBtn" data-difficulty="hard" class="btn btn-primary">Hard</button>
                    <button id="hellBtn" data-difficulty="hell" class="btn btn-primary">Hell (Multi-Answer)</button>
                </div>
            </div>

            <div id="gameScreen" class="test-container hidden">
                <div class="game-layout">
                    <div class="question-sidebar">
                        <h3>Questions</h3>
                        <div id="questionGrid" class="question-grid"></div>
                        <div id="legendContainer" class="legend">
                            <div class="legend-item"><div class="legend-color" style="background:var(--secondary-color)"></div> Current</div>
                            <div class="legend-item"><div class="legend-color" style="background:var(--primary-color)"></div> Answered</div>
                            <div class="legend-item"><div class="legend-color" style="background:var(--bg-color-light)"></div> Not Answered</div>
                        </div>
                    </div>
                    <div class="game-content">
                        <div class="status-bar">
                            <div id="questionCounter"></div>
                            <!-- ‡∏•‡∏ö Timer ‡πÄ‡∏î‡∏¥‡∏°‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß -->
                        </div>
                        <div class="question-section">
                            <p>When folded into a 3D box, which configuration is possible?</p>
                            <div id="patternDisplay"></div>
                        </div>
                        <div id="choicesContainer" class="choices-container"></div>
                        <div id="practice-review-cube-area" class="review-cube-area hidden">
                            <h3>Correctly Folded Box:</h3>
                            <div class="cube-control-wrapper" style="width: 100%; height: 150px;">
                                <div class="cube-container-interactive" style="cursor: grab;">
                                    <div class="interactive-cube" id="practice-review-interactive-cube">
                                        <div class="face front"></div>
                                        <div class="face back"></div>
                                        <div class="face left"></div>
                                        <div class="face right"></div>
                                        <div class="face top"></div>
                                        <div class="face bottom"></div>
                                    </div>
                                </div>
                                <p style="margin-top: 120px; font-size: 0.8rem; color: #888;">(Click & Drag to Rotate)</p>
                            </div>
                        </div>
                        <div id="navigationControls" class="navigation-controls"></div>
                    </div>
                </div>
            </div>

            <div id="resultsScreen" class="test-container results-container
hidden">
                <h2 id="resultsTitle"></h2>
                <div id="practiceResults" class="result-summary hidden">
                    <p>Score: <strong id="practiceScore">0 / 35</strong></p>
                    <p>Accuracy: <strong id="practiceAccuracy">0.00%</strong></p>
                </div>
                <div id="testResults" class="result-comparison hidden">
                    <div class="result-column">
                        <h3>Current Score</h3>
                        <div class="result-grid">
                            <span>Score</span><span id="currentScoreDisplay">N/A</span>
                            <span>Accuracy</span><span id="currentAccuracyDisplay">N/A</span>
                            <span>Avg. Time / Q</span><span id="avgTimeDisplay">N/A</span>
                            <span>Percentile</span><span id="currentPercentileDisplay">N/A</span>
                        </div>
                    </div>
                    <div class="result-column">
                        <h3>Your Best Score</h3>
                        <div class="result-grid">
                            <span>Score</span><span id="bestScoreDisplay">N/A</span>
                            <span>Accuracy</span><span id="bestAccuracyDisplay">N/A</span>
                            <span>Percentile</span><span id="bestPercentileDisplay">N/A</span>
                        </div>
                    </div>
                </div>
                <div class="action-buttons">
                    <button id="reviewBtn" class="btn btn-secondary hidden">Review Answers</button>
                    <button id="retakeBtn" class="btn btn-primary">Back to Menu</button>
                    <button class="btn outline-btn back-to-system-btn">Back to Main Page</button>
                </div>
                .
            </div>

            <div id="reviewScreen" class="test-container hidden">
                <div class="game-layout">
                    <div class="question-sidebar">
                        <h3>Review Nav</h3>
                        <div id="reviewNavGrid" class="question-grid"></div>
                    </div>
                    <div class="game-content">
                        <div class="status-bar"><div id="reviewQuestionCounter"></div></div>
                        <div class="question-section">
                            <div id="reviewPatternDisplay"></div>
                        </div>
                        <div id="reviewChoicesContainer" class="choices-container"></div>
                        <div class="review-cube-area">
                            <h3>Correctly Folded Box:</h3>
                            <div class="cube-control-wrapper" style="width: 100%; height: 150px;">
                                <div class="cube-container-interactive" style="cursor: grab;">
                                    <div class="interactive-cube" id="reviewInteractiveCube">
                                        <div class="face front"></div>
                                        <div class="face back"></div>
                                        <div class="face left"></div>
                                        <div class="face right"></div>
                                        <div class="face top"></div>
                                        <div class="face bottom"></div>
                                    </div>
                                </div>
                                <p style="margin-top: 120px; font-size: 0.8rem; color: #888;">(Click & Drag to Rotate)</p>
                            </div>

                            <div class="navigation-controls">
                                <button id="reviewPrevBtn" class="btn btn-secondary">&lt; Prev</button>
                                <button id="reviewNextBtn" class="btn btn-secondary">Next &gt;</button>
                            </div>
                        </div>

                    </div>
                </div>
            </div>
        </div>

        <div id="confirmModal" class="modal">
            <div class="modal-content">
                <h2>Confirm Submission</h2><p>Are you sure?</p>
                <div class="action-buttons" style="flex-direction:row; justify-content:center;">
                    <button id="cancelSubmitBtn" class="btn btn-secondary">Cancel</button>
                    <button id="confirmSubmitBtn" class="btn btn-primary">Submit</button>
                </div>
            </div>
        </div>

        <script>
            // --- START: ADDED FOR MOCKUP TEST ---
            const urlParams = new URLSearchParams(window.location.search);
            const isMockupMode = urlParams.get('mode') === 'mockup';
            // --- END: ADDED FOR MOCKUP TEST ---

            // Constants & State
            const TOTAL_QUESTIONS = 35, TIME_LIMIT = 360;

            let questions = [], userAnswers = [], currentQuestionIndex = 0, reviewQuestionIndex = 0, timerInterval = null, timeLeft = TIME_LIMIT;
            let gameState = { mode: 'test', difficulty: 'normal' }; // <-- MODIFIED
            let currentSymbolMapping = {};

            // --- ‚≠êÔ∏è START: ‡πÇ‡∏Ñ‡πâ‡∏î Auth (‡∏â‡∏ö‡∏±‡∏ö Fetch API) ‚≠êÔ∏è ---
            let currentUserEmail = null;

            auth.onAuthStateChanged(user => {
                if (user) {
                    // 1. User Login ‡πÅ‡∏•‡πâ‡∏ß
                    loader.style.display = 'flex';
                    currentUserEmail = user.email || user.providerData[0]?.email;

                    // ‡∏Å‡∏£‡∏ì‡∏µ Test ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Hardcode (‡∏•‡∏ö‡∏≠‡∏≠‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏∂‡πâ‡∏ô Production)
                    if (!currentUserEmail) currentUserEmail = "kritsada.wongtiwanon@gmail.com";

                    console.log("Checking Access for:", currentUserEmail);

                    // 2. ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Cloud Function ‡πÅ‡∏ö‡∏ö Fetch (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô saveScore)
                    const CHECK_ACCESS_URL = "https://us-central1-silp-pilot-platform.cloudfunctions.net/checkUserAccess";

                    fetch(CHECK_ACCESS_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            email: currentUserEmail,
                            courseId: 'foldingBox'
                        })
                    })
                        .then(response => response.json())
                        .then(result => {
                            if (result.hasAccess === true) {
                                console.log("Authorization Success: Access Granted.");
                                loader.style.display = 'none';
                            } else {
                                console.log("Authorization Failed:", result.reason);
                                alert(`Access Denied: ${result.reason}. Redirecting...`);
                                window.location.href = '/index.html';
                            }
                        })
                        .catch(error => {
                            console.error("API Error:", error);
                            alert(`Connection Error: ${error.message}`);
                            window.location.href = '/index.html';
                        });

                } else {
                    console.log("User not logged in. Redirecting...");
                    window.location.href = '/Auth.html';
                }
            });
            // --- ‚≠êÔ∏è END: ‡πÇ‡∏Ñ‡πâ‡∏î Auth ‚≠êÔ∏è ---

            // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å‡πÄ‡∏°‡∏≤‡∏™‡πå
            let isDragging = false;
            let previousMouseX = 0;
            let previousMouseY = 0;

            // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö Cube ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
            function enableMouseRotation(cubeId) {
                const cube = document.getElementById(cubeId);
                if (!cube) return;

                // ‡∏à‡∏±‡∏ö event ‡∏ó‡∏µ‡πà container (parent) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢
                const container = cube.parentElement;

                // Mouse Events
                container.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                    cube.style.cursor = 'grabbing';
                    e.preventDefault(); // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å text
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    const deltaX = e.clientX - previousMouseX;
                    const deltaY = e.clientY - previousMouseY;

                    // ‡∏õ‡∏£‡∏±‡∏ö‡∏≠‡∏á‡∏®‡∏≤‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô (‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß 0.5)
                    // ‡∏•‡∏≤‡∏Å‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤ -> ‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡πÅ‡∏Å‡∏ô Y
                    // ‡∏•‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô‡∏•‡∏á -> ‡∏´‡∏°‡∏∏‡∏ô‡∏£‡∏≠‡∏ö‡πÅ‡∏Å‡∏ô X
                    currentYRotation += deltaX * 0.5;
                    currentXRotation -= deltaY * 0.5;

                    cube.style.transform = `rotateX(${currentXRotation}deg) rotateY(${currentYRotation}deg) rotateZ(${currentZRotation}deg)`;

                    previousMouseX = e.clientX;
                    previousMouseY = e.clientY;
                });

                window.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        cube.style.cursor = 'grab';
                    }
                });

                // Touch Events (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠/‡πÅ‡∏ó‡πá‡∏ö‡πÄ‡∏•‡πá‡∏ï)
                container.addEventListener('touchstart', (e) => {
                    isDragging = true;
                    previousMouseX = e.touches[0].clientX;
                    previousMouseY = e.touches[0].clientY;
                    e.preventDefault();
                }, { passive: false });

                window.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const deltaX = e.touches[0].clientX - previousMouseX;
                    const deltaY = e.touches[0].clientY - previousMouseY;

                    currentYRotation += deltaX * 0.5;
                    currentXRotation -= deltaY * 0.5;

                    cube.style.transform = `rotateX(${currentXRotation}deg) rotateY(${currentYRotation}deg) rotateZ(${currentZRotation}deg)`;

                    previousMouseX = e.touches[0].clientX;
                    previousMouseY = e.touches[0].clientY;
                    e.preventDefault();
                }, { passive: false });

                window.addEventListener('touchend', () => {
                    isDragging = false;
                });
            }

            const screens = {
                start: document.getElementById('startScreen'),
                difficulty: document.getElementById('difficultyScreen'),
                howToPlay: document.getElementById('howToPlayScreen'),
                game: document.getElementById('gameScreen'),
                results: document.getElementById('resultsScreen'),
                review: document.getElementById('reviewScreen')
            };
            const loader = document.getElementById('loader-overlay');
            const modal = document.getElementById('confirmModal');
            const mainHeader = document.getElementById('mainHeader');
            const quizSystemUrl = document.body.dataset.homeUrl;

            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
            document.addEventListener('DOMContentLoaded', () => {

                // --- START: MODIFIED FOR MOCKUP TEST ---
                if (isMockupMode) {
                    startGame('test');
                    return;
                }
                // --- END: MODIFIED FOR MOCKUP TEST ---
                // --- Mobile Sidebar Toggle ---
                const sidebar = document.querySelector('.question-sidebar');
                const overlay = document.getElementById('sidebarOverlay');
                const hamburger = document.getElementById('hamburgerBtn');

                function toggleSidebar() {
                    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤ Sidebar "‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß" ‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö (‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏£‡∏≤‡∏°‡∏µ 2 ‡∏≠‡∏±‡∏ô)
                    const allSidebars = document.querySelectorAll('.question-sidebar');
                    const overlay = document.getElementById('sidebarOverlay');

                    // ‡∏™‡∏±‡πà‡∏á Toggle class active ‡πÉ‡∏´‡πâ Sidebar ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß (‡∏ï‡∏±‡∏ß‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤ hidden ‡∏Å‡πá‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÄ‡∏´‡πá‡∏ô‡∏ú‡∏• ‡∏ã‡∏∂‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß)
                    allSidebars.forEach(sidebar => {
                        sidebar.classList.toggle('active');
                    });

                    overlay.classList.toggle('active');
                }

                hamburger.addEventListener('click', toggleSidebar);
                overlay.addEventListener('click', toggleSidebar); // ‡∏Å‡∏î‡∏â‡∏≤‡∏Å‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏¥‡∏î

                // ‡∏õ‡∏¥‡∏î Sidebar ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠ (‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠)
                document.getElementById('questionGrid').addEventListener('click', (e) => {
                    if (window.innerWidth <= 992 && e.target.tagName === 'BUTTON') {
                        toggleSidebar();
                    }
                });

                document.getElementById('practiceModeBtn').addEventListener('click', () => selectMode('practice'));
                document.getElementById('testModeBtn').addEventListener('click', () => selectMode('test'));
                document.getElementById('howToPlayBtn').addEventListener('click', showTutorial);
                document.getElementById('backToStartBtn').addEventListener('click', () => switchScreen('start'));
                document.getElementById('retakeBtn').addEventListener('click', backToStart);
                document.getElementById('backToMenuBtn').addEventListener('click', backToStart);
                document.getElementById('cancelSubmitBtn').addEventListener('click', () => modal.classList.remove('active'));
                document.getElementById('confirmSubmitBtn').addEventListener('click', () => { modal.classList.remove('active'); submitQuiz(false); });
                document.querySelectorAll('.back-to-system-btn').forEach(btn => btn.addEventListener('click', () => { loader.style.display = 'flex'; window.open(quizSystemUrl, '_top'); }));
                document.getElementById('reviewBtn').addEventListener('click', showReview);
                document.getElementById('backToResultsBtn').addEventListener('click', () => switchScreen('results'));
                document.getElementById('reviewPrevBtn').addEventListener('click', () => jumpToReviewQuestion(reviewQuestionIndex - 1));
                document.getElementById('reviewNextBtn').addEventListener('click', () => jumpToReviewQuestion(reviewQuestionIndex + 1));

                // Difficulty Buttons
                document.getElementById('easyBtn').addEventListener('click', () => startGame('easy'));
                document.getElementById('normalBtn').addEventListener('click', () => startGame('normal'));
                document.getElementById('hardBtn').addEventListener('click', () => startGame('hard'));
                document.getElementById('hellBtn').addEventListener('click', () => startGame('hell'));

                // --- ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏°‡∏∏‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏°‡∏≤‡∏™‡πå ---
                enableMouseRotation('reviewInteractiveCube');
                enableMouseRotation('practice-review-interactive-cube');
            });

            function switchScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.add('hidden'));
                screens[screenName].classList.remove('hidden');

                // --- START: MODIFIED FOR MOCKUP TEST ---
                if (isMockupMode) {
                    mainHeader.style.display = 'none';
                } else {
                    document.querySelector('.container').style.paddingTop = '80px';
                }
                // --- END: MODIFIED FOR MOCKUP TEST ---

                const backToMenuBtn = document.getElementById('backToMenuBtn');
                const backToResultsBtn = document.getElementById('backToResultsBtn');

                backToMenuBtn.classList.toggle('hidden', !(screenName === 'game' && gameState.mode === 'practice'));
                backToResultsBtn.classList.toggle('hidden', !(screenName === 'review' && gameState.mode === 'test'));
            }

            function backToStart() {
                if (timerInterval) clearInterval(timerInterval);
                switchScreen('start');
            }

            // --- START: ADDED FUNCTION ---
            function selectMode(mode) {
                gameState.mode = mode;
                document.getElementById('difficultyTitle').textContent = `Select ${mode.charAt(0).toUpperCase() + mode.slice(1)} Difficulty`;
                switchScreen('difficulty');
            }
            // --- END: ADDED FUNCTION ---

            async function showTutorial() {
                loader.style.display = 'flex';
                try {
                    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£ Hardcode
                    const res = await fetch("https://us-central1-silp-pilot-platform.cloudfunctions.net/getTutorialData");
                    const result = await res.json();

                    if (result.success) {
                        switchScreen('howToPlay');
                        currentSymbolMapping = result.data.symbolMapping;
                        document.getElementById('tutorial-pattern').innerHTML = create2DPattern(result.data.pattern);
                        document.getElementById('tutorial-cube').innerHTML = create3DCube(result.data.cube);
                    }
                } catch (e) {
                    console.error("Tutorial load failed", e);
                    alert("Could not load tutorial.");
                } finally {
                    loader.style.display = 'none';
                }
            }

            async function startGame(difficulty) {
                gameState.difficulty = difficulty;
                document.getElementById('loader-overlay').style.display = 'flex';

                try {
                    const FUNCTION_URL = "https://us-central1-silp-pilot-platform.cloudfunctions.net/getFoldingBoxQuizData";
                    const response = await fetch(`${FUNCTION_URL}?difficulty=${difficulty}`);
                    const result = await response.json();

                    if (result.success) {
                        // [FIX 3] ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å onQuizDataReceived ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏û‡∏≠
                        // (‡∏Ç‡πâ‡∏≤‡∏á‡πÉ‡∏ô‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏µ logic ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å startTimer ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ã‡πâ‡∏≥‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ)
                        onQuizDataReceived(result.data);

                    } else {
                        alert("Error: " + (result.error || "Unknown error from server"));
                        switchScreen('start');
                        document.getElementById('loader-overlay').style.display = 'none';
                    }
                } catch (error) {
                    console.error("Connection failed:", error);
                    alert("Failed to connect to server. Please check your internet connection.");
                    switchScreen('start');
                    document.getElementById('loader-overlay').style.display = 'none';
                }
                // ‡∏¢‡πâ‡∏≤‡∏¢ finally ‡∏≠‡∏≠‡∏Å ‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ loader ‡πÉ‡∏ô if/else ‡πÅ‡∏ó‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô loader ‡∏õ‡∏¥‡∏î‡∏Å‡πà‡∏≠‡∏ô render ‡πÄ‡∏™‡∏£‡πá‡∏à
            }

            /**
            * This function is the success handler for our server-side call.
            * It receives the question data from the server.
            */
            function onQuizDataReceived(data) {
                userAnswers = new Array(TOTAL_QUESTIONS).fill(null);
                currentQuestionIndex = 0;

                if (data.error) {
                    alert(data.error);
                    document.getElementById('loader-overlay').style.display = 'none';
                    return;
                }

                questions = data;
                document.body.classList.toggle('practice-mode-active', gameState.mode === 'practice');
                switchScreen('game');

                // [FIX 2 & 3] ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ID ‡∏ú‡∏¥‡∏î ‡πÅ‡∏•‡∏∞ Logic Timer
                const timerEl = document.getElementById('headerTimer');
                if (gameState.mode === 'test') {
                    timerEl.style.display = 'block';
                    startTimer();
                } else {
                    timerEl.style.display = 'none';
                }

                displayQuestion();
                document.getElementById('loader-overlay').style.display = 'none';
            }

            /**
             * Analyzes the 2D pattern grid to find opposite faces.
             * Assumes a standard 'cross' or similar foldable net pattern.
             * Returns a mapping like { '1': '6', '6': '1', '2': '4', ... }
             */
            function findOpposites(pattern) {
                const coords = {}; // Store { number: [row, col] }
                for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[r].length; c++) {
                        if (pattern[r][c]) {
                            coords[pattern[r][c]] = [r, c];
                        }
                    }
                }

                const numbers = Object.keys(coords);
                if (numbers.length !== 6) {
                    console.error("Pattern does not contain exactly 6 faces:", pattern);
                    return {}; // Cannot determine opposites
                }

                const opposites = {};

                for (let i = 0; i < numbers.length; i++) {
                    const num1 = numbers[i];
                    if (opposites[num1]) continue; // Already found pair

                    const [r1, c1] = coords[num1];

                    for (let j = i + 1; j < numbers.length; j++) {
                        const num2 = numbers[j];
                        const [r2, c2] = coords[num2];

                        // Check for distance 2 in same row or col (common in cross patterns)
                        if ((r1 === r2 && Math.abs(c1 - c2) === 2) || (c1 === c2 && Math.abs(r1 - r2) === 2)) {
                            // Check if there's a face *between* them
                            const betweenRow = (r1 + r2) / 2;
                            const betweenCol = (c1 + c2) / 2;
                            let foundBetween = false;
                            for (const num3 in coords) {
                                if (coords[num3][0] === betweenRow && coords[num3][1] === betweenCol) {
                                    foundBetween = true;
                                    break;
                                }
                            }
                            if (foundBetween) {
                                opposites[num1] = num2;
                                opposites[num2] = num1;
                                break; // Found opposite for num1
                            }
                        }
                        // Check for L-shape distance (less common, but possible in some nets)
                        // Example: 1 step row, 2 steps col OR 2 steps row, 1 step col might indicate opposites in compact nets
                        // This logic can get complex, sticking to simple cross for now.
                    }
                }

                // Try to deduce the last pair if 4 are found
                if (Object.keys(opposites).length === 4) {
                    const remaining = numbers.filter(n => !opposites[n]);
                    if (remaining.length === 2) {
                        opposites[remaining[0]] = remaining[1];
                        opposites[remaining[1]] = remaining[0];
                    }
                }

                // Basic validation - check if all numbers 1-6 are keys
                const allKeys = Object.keys(opposites);
                if (allKeys.length !== 6 || !['1', '2', '3', '4', '5', '6'].every(n => allKeys.includes(n))) {
                    console.warn("Could not reliably determine all opposites for pattern:", pattern, "Found:", opposites);
                    // Fallback or default logic might be needed here if patterns are complex
                }


                return opposites;
            }

            const getBaseNumber = (faceIdentifier) => {
                if (typeof faceIdentifier !== 'string') return String(faceIdentifier);
                const num = faceIdentifier.slice(0, -1);
                if (['U', 'D', 'L', 'R'].includes(faceIdentifier.slice(-1))) {
                    return num;
                }
                return String(faceIdentifier); // Fallback for 'old' type
            };
            const getOrientation = (faceIdentifier) => {
                const orientation = faceIdentifier.slice(-1);
                if (['U', 'D', 'L', 'R'].includes(orientation)) {
                    return orientation;
                }
                return 'U'; // Default for 'old' type (doesn't matter)
            };
            const getOppositeOrientation = (orientation) => {
                if (orientation === 'U') return 'D';
                if (orientation === 'D') return 'U';
                if (orientation === 'L') return 'R';
                if (orientation === 'R') return 'L';
                return 'U'; // Fallback
            };

            const getChoiceFaceHtml = (faceIdentifier, faceIndex) => {
                faceIdentifier = String(faceIdentifier);

                // [FIX 1] ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Crash ‡∏ñ‡πâ‡∏≤ Mapping ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
                if (!currentSymbolMapping) return '?';

                const isRotated = ['U', 'D', 'L', 'R'].includes(faceIdentifier.slice(-1));
                let baseRotation = 0;
                let symbol = '';

                if (isRotated) {
                    const number = faceIdentifier.slice(0, -1);
                    const orientation = faceIdentifier.slice(-1);
                    symbol = currentSymbolMapping[number] || '?';

                    const logicTable = {
                        'U': [90, 0, 0], 'D': [270, 180, 180],
                        'L': [0, 270, 270], 'R': [180, 90, 90]
                    };
                    baseRotation = (faceIndex >= 0 && faceIndex <= 2 && logicTable[orientation]) ?
                        logicTable[orientation][faceIndex] : 0;
                } else {
                    symbol = currentSymbolMapping[getBaseNumber(faceIdentifier)] || '';
                    baseRotation = 0;
                }

                return `<span style="display:inline-block; transform: rotate(${baseRotation}deg);">${symbol}</span>`;
            };

            /**
             * For Review Cube (Full 6 faces)
             * Applies simple rotation based on the face's defined orientation.
             * faceIndex 0=Top, 1=Left, 2=Front, 3=Back, 4=Right, 5=Bottom
             */
            const getReviewFaceHtml = (faceIdentifier, faceIndex) => {
                const isRotated = typeof faceIdentifier === 'string' && ['U', 'D', 'L', 'R'].includes(faceIdentifier.slice(-1));
                let baseRotation = 0;
                let symbol = '';

                if (isRotated) {
                    const number = faceIdentifier.slice(0, -1);
                    const orientation = faceIdentifier.slice(-1);
                    symbol = currentSymbolMapping[number] || '?';

                    // Simple map: 'U' is 0 deg, 'R' is 90 deg, etc.
                    const rotationMap = {
                        'U': 0,
                        'R': 90,
                        'D': 180,
                        'L': 270
                    };
                    baseRotation = rotationMap[orientation] !== undefined ? rotationMap[orientation] : 0;

                } else {
                    // 'old' type
                    symbol = currentSymbolMapping[getBaseNumber(faceIdentifier)] || '';
                    baseRotation = 0;
                }

                // --- START: MODIFIED LOGIC ---
                // Apply +90 for Top face (index 0) and -90 for Bottom face (index 5)
                if (faceIndex === 0) {
                    baseRotation += 90;
                } else if (faceIndex === 5) {
                    baseRotation -= 90; // <-- ADDED: Specific rotation for Bottom face
                }
                // --- END: MODIFIED LOGIC ---

                return `<span style="display:inline-block; transform: rotate(${baseRotation}deg);">${symbol}</span>`;
            };

            // --- START: ADDED REUSABLE FUNCTION ---
            function populateInteractiveCube(cubeId, question) {
                const interactiveCube = document.getElementById(cubeId);
                if (!interactiveCube) return;

                currentSymbolMapping = question.symbolMapping; // Ensure correct map is loaded

                const faceElements = {
                    front: interactiveCube.querySelector('.face.front'),
                    back: interactiveCube.querySelector('.face.back'),
                    left: interactiveCube.querySelector('.face.left'),
                    right: interactiveCube.querySelector('.face.right'),
                    top: interactiveCube.querySelector('.face.top'),
                    bottom: interactiveCube.querySelector('.face.bottom')
                };
                Object.values(faceElements).forEach(face => face.innerHTML = '');

                let topFaceId = null, leftFaceId = null, frontFaceId = null;
                let bottomFaceId = null, rightFaceId = null, backFaceId = null;

                // *** START MODIFICATION ***
                // Prioritize 'foldedbox' if it exists, regardless of 'type'
                // This fixes both Problem 1 and Problem 2's source
                if (question.foldedbox && question.foldedbox.length === 6) {
                    topFaceId = question.foldedbox[0];
                    leftFaceId = question.foldedbox[1];
                    frontFaceId = question.foldedbox[2];
                    backFaceId = question.foldedbox[3];
                    rightFaceId = question.foldedbox[4];
                    bottomFaceId = question.foldedbox[5];
                } else {
                    // Fallback (old logic) - This should no longer be used if you updated gs_Rev11.txt
                    console.error("Missing 'foldedbox' data for question:", question);
                    const opposites = findOpposites(question.pattern);
                    let firstCorrectAnswer = question.correctChoice || (question.correctChoices ? question.correctChoices[0] : ['1', '2', '3']);

                    topFaceId = String(firstCorrectAnswer[0]);
                    leftFaceId = String(firstCorrectAnswer[1]);
                    frontFaceId = String(firstCorrectAnswer[2]);

                    if (Object.keys(opposites).length === 6) {
                        bottomFaceId = opposites[topFaceId] || null;
                        rightFaceId = opposites[leftFaceId] || null;
                        backFaceId = opposites[frontFaceId] || null;
                    }
                }
                // *** END MODIFICATION ***


                // Use the correct function: getReviewFaceHtml
                if (faceElements.top) faceElements.top.innerHTML = getReviewFaceHtml(topFaceId, 0);
                if (faceElements.left) faceElements.left.innerHTML = getReviewFaceHtml(leftFaceId, 1);
                if (faceElements.front) faceElements.front.innerHTML = getReviewFaceHtml(frontFaceId, 2);
                if (faceElements.back) faceElements.back.innerHTML = getReviewFaceHtml(backFaceId, 3);
                if (faceElements.right) faceElements.right.innerHTML = getReviewFaceHtml(rightFaceId, 4);
                if (faceElements.bottom) faceElements.bottom.innerHTML = getReviewFaceHtml(bottomFaceId, 5);


                // Reset rotation
                currentXRotation = -25;
                currentYRotation = 45;
                currentZRotation = 0;
                interactiveCube.style.transform = `rotateX(${currentXRotation}deg) rotateY(${currentYRotation}deg) rotateZ(${currentZRotation}deg)`;
            }
            // --- END: ADDED REUSABLE FUNCTION ---

            function renderReviewQuestion() {
                const q = questions[reviewQuestionIndex];
                if (!q) return; // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Error

                currentSymbolMapping = q.symbolMapping;
                document.getElementById('reviewQuestionCounter').textContent = `Question ${reviewQuestionIndex + 1} / ${TOTAL_QUESTIONS}`;
                document.getElementById('reviewPatternDisplay').innerHTML = create2DPattern(q);

                populateInteractiveCube('reviewInteractiveCube', q);

                // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Layout ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Hell Mode
                const reviewContainer = document.getElementById('reviewChoicesContainer');
                const reviewCubeArea = document.querySelector('#reviewScreen .review-cube-area');

                if (gameState.difficulty === 'hell') {
                    reviewContainer.classList.add('hell-review-mode');
                    if (reviewCubeArea) reviewCubeArea.classList.add('review-area-hell-compact');
                } else {
                    reviewContainer.classList.remove('hell-review-mode');
                    if (reviewCubeArea) reviewCubeArea.classList.remove('review-area-hell-compact');
                }

                // --- ‡∏™‡πà‡∏ß‡∏ô‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏• Choice ---
                let choicesHTML = '';
                const userAnswer = userAnswers[reviewQuestionIndex];
                // [‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç] ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£ keyLabels ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏¥‡∏î Error
                const keyLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

                if (q.correctChoices) {
                    // --- HELL MODE REVIEW ---
                    const userChoiceIndices = userAnswer || [];
                    const correctChoiceKeys = new Set(q.correctChoices.map(c => [...c].sort().join('-')));
                    const allChoiceKeys = q.choices.map(c => [...c].sort().join('-'));

                    q.choices.forEach((choice, index) => {
                        const choiceKey = allChoiceKeys[index];
                        const isCorrect = correctChoiceKeys.has(choiceKey);
                        const isUserSelected = userChoiceIndices.includes(index);

                        let choiceClass = 'disabled';
                        if (isCorrect) choiceClass += ' correct';
                        if (isUserSelected) choiceClass += ' user-selected';
                        if (isUserSelected && !isCorrect) choiceClass += ' incorrect';

                        const keyLabel = keyLabels[index] || '';
                        choicesHTML += `<div class="choice-button ${choiceClass}">
                                            <span class="key-hint">${keyLabel}</span>
                                            ${create3DCube(choice)}
                                        </div>`;
                    });
                } else {
                    // --- EASY/NORMAL/HARD REVIEW ---
                    const userAnswerIndex = userAnswer;
                    q.choices.forEach((choice, index) => {
                        const isCorrect = JSON.stringify(choice) === JSON.stringify(q.correctChoice);
                        let choiceClass = 'disabled';
                        if (isCorrect) choiceClass += ' correct';

                        if (index === userAnswerIndex) {
                            choiceClass += ' user-selected';
                            if (!isCorrect) choiceClass += ' incorrect';
                        } else if (!isCorrect) {
                            choiceClass += ' incorrect'; // ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏à‡∏≤‡∏á‡∏•‡∏á
                        }

                        const keyLabel = keyLabels[index] || '';
                        choicesHTML += `<div class="choice-button ${choiceClass}">
                                            <span class="key-hint">${keyLabel}</span>
                                            ${create3DCube(choice)}
                                        </div>`;
                    });
                }

                document.getElementById('reviewChoicesContainer').innerHTML = choicesHTML;

                // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Render Nav ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ß‡∏≤‡∏î Choice ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß
                renderReviewNav();

                document.getElementById('reviewPrevBtn').disabled = reviewQuestionIndex === 0;
                document.getElementById('reviewNextBtn').disabled = reviewQuestionIndex === TOTAL_QUESTIONS - 1;
            }



            function displayQuestion() {
                const container = document.getElementById('choicesContainer');
                const practiceArea = document.getElementById('practice-review-cube-area');

                // 1. ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô (Reset)
                container.classList.remove('hell-mode', 'hell-review-mode');
                practiceArea.classList.remove('review-area-hell-compact');
                practiceArea.classList.add('hidden');

                // 2. [‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç] ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç: ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô Practice Mode AND Hell Level
                // ‡πÉ‡∏´‡πâ‡πÉ‡∏™‡πà Class ‡∏¢‡πà‡∏≠‡∏™‡πà‡∏ß‡∏ô (.hell-review-mode) ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°!
                if (gameState.mode === 'practice' && gameState.difficulty === 'hell') {
                    container.classList.add('hell-review-mode');
                    practiceArea.classList.add('review-area-hell-compact');
                }

                const q = questions[currentQuestionIndex];

                // ‡πÉ‡∏ä‡πâ mapping ‡∏à‡∏≤‡∏Å‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏Ç‡πâ‡∏≠‡∏ô‡∏±‡πâ‡∏ô‡πÜ ‡πÄ‡∏•‡∏¢
                if (q.symbolMapping) {
                    currentSymbolMapping = q.symbolMapping;
                } else {
                    console.error("Symbol mapping missing from server data!");
                    currentSymbolMapping = {};
                }

                document.getElementById('questionCounter').textContent = `Question ${currentQuestionIndex + 1} / ${TOTAL_QUESTIONS}`;
                document.getElementById('patternDisplay').innerHTML = create2DPattern(q);

                let choicesHTML = '';
                const isHell = gameState.difficulty === 'hell';
                const currentAnswers = userAnswers[currentQuestionIndex];
                const keyLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']; // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ñ‡∏∂‡∏á Hell Mode (8 ‡∏ï‡∏±‡∏ß)

                q.choices.forEach((choice, index) => {
                    let isSelected = false;
                    if (isHell) {
                        isSelected = (currentAnswers || []).includes(index);
                    } else {
                        isSelected = (currentAnswers === index);
                    }

                    // [‡πÄ‡∏û‡∏¥‡πà‡∏°] ‡∏™‡∏£‡πâ‡∏≤‡∏á Label A, B, C... ‡∏ï‡∏≤‡∏° Index
                    const keyLabel = keyLabels[index] || '';

                    choicesHTML += `
                        <div class="choice-button ${isSelected ? 'selected' : ''}" onclick="selectAnswer(${index})">
                            <span class="key-hint">${keyLabel}</span> ${create3DCube(choice)}
                        </div>`;
                });
                document.getElementById('choicesContainer').innerHTML = choicesHTML;

                updateNavigation();
            }

            function create2DPattern(q) {
                let patternHTML = '<div class="pattern-grid">';
                q.pattern.forEach(row => row.forEach(cell => {
                    patternHTML += `<div class="pattern-cell ${cell ? '' : 'empty'}">${cell ? currentSymbolMapping[cell] : ''}</div>`;
                }));
                return patternHTML + '</div>';
            }

            function create3DCube(faces) {
                // faces[0] = Top face identifier (e.g., "1U")
                // faces[1] = Left face identifier (e.g., "2U")
                // faces[2] = Front face identifier (e.g., "3U")

                // Call this 3 times using the correct function for *choices*
                const topFace = getChoiceFaceHtml(faces[0], 0);    // faceIndex 0 (Top)
                const leftFace = getChoiceFaceHtml(faces[1], 1);  // faceIndex 1 (Left)
                const frontFace = getChoiceFaceHtml(faces[2], 2); // faceIndex 2 (Front)

                return `<div class="cube-container"><div class="cube">
                                                                                                                                                                                                                                    <div class="cube-face top">${topFace}</div>
                                                                                                                                                                                                                                    <div class="cube-face left">${leftFace}</div>
                                                                                                                                                                                                                                    <div class="cube-face front">${frontFace}</div>
                                                                                                                                                                                                                                </div></div>`;
            }

            function selectAnswer(choiceIndex) {
                const isHell = gameState.difficulty === 'hell';

                if (isHell) {
                    let currentAnswers = userAnswers[currentQuestionIndex] || [];
                    const answerIndexInArray = currentAnswers.indexOf(choiceIndex);

                    if (answerIndexInArray > -1) {
                        // Deselect
                        currentAnswers.splice(answerIndexInArray, 1);
                    } else {
                        // Select
                        currentAnswers.push(choiceIndex);
                    }
                    userAnswers[currentQuestionIndex] = currentAnswers;
                } else {
                    // Easy, Medium, Hard (Single select)
                    userAnswers[currentQuestionIndex] = choiceIndex;
                }

                // Re-render choices to show new selection state
                displayQuestion();

                // Update side nav in Test Mode
                if (gameState.mode === 'test') {
                    renderSideNav();
                }

                // Update nav controls (e.g., enable "Check Answer" in Practice)
                updateNavigation();
                // --- ‚¨áÔ∏è START: FIX (Auto-advance) ‚¨áÔ∏è ---
                if (gameState.mode === 'test' && gameState.difficulty !== 'hell') {
                    if (currentQuestionIndex < TOTAL_QUESTIONS - 1) {
                        setTimeout(() => {
                            currentQuestionIndex++;
                            displayQuestion();
                        }, 200); // ‡∏´‡∏ô‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ 200ms ‡πÉ‡∏´‡πâ user ‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß
                    } else {
                        // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢ ‡πÉ‡∏´‡πâ user ‡∏Å‡∏î Submit ‡πÄ‡∏≠‡∏á
                    }
                }
                // --- ‚¨ÜÔ∏è END: FIX ‚¨ÜÔ∏è ---
            }


            function updateNavigation() {
                const nav = document.getElementById('navigationControls');
                nav.innerHTML = '';
                nav.className = 'navigation-controls';

                if (gameState.mode === 'practice') {
                    nav.classList.add('center');
                    const choicesContainer = document.getElementById('choicesContainer');
                    const hasBeenChecked = choicesContainer.querySelector('.choice-button.correct, .choice-button.incorrect');

                    if (hasBeenChecked) {
                        if (currentQuestionIndex < TOTAL_QUESTIONS - 1) {
                            // [‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠ 5] ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏∏‡πà‡∏°
                            nav.innerHTML = `<button class="btn btn-secondary" onclick="currentQuestionIndex++; displayQuestion();">Next &gt;</button>`;
                        } else {
                            nav.innerHTML = `<button class="btn btn-primary" onclick="submitQuiz()">Finish Practice</button>`;
                        }
                    } else {
                        nav.innerHTML = `<button class="btn btn-success" ${!userAnswers.hasOwnProperty(currentQuestionIndex) ? 'disabled' : ''} onclick="handleCheckAnswer()">Check Answer</button>`;
                    }
                } else {
                    renderSideNav();
                    // [‡πÅ‡∏Å‡πâ‡∏Ç‡πâ‡∏≠ 2] ‡πÉ‡∏ä‡πâ Flexbox ‡∏à‡∏±‡∏î‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡∏¢‡∏∑‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà
                    nav.innerHTML = `
                        <div style="display: flex; gap: 10px; width: 100%;">
                            <button class="btn btn-secondary" style="flex: 1; padding: 8px;" ${currentQuestionIndex === 0 ? 'disabled' : ''} onclick="currentQuestionIndex--; displayQuestion();">&lt; Prev</button>
                            <button class="btn btn-primary" style="flex: 1.5; padding: 8px;" onclick="modal.classList.add('active')">Submit</button>
                            <button class="btn btn-secondary" style="flex: 1; padding: 8px;" ${currentQuestionIndex === TOTAL_QUESTIONS - 1 ? 'disabled' : ''} onclick="currentQuestionIndex++; displayQuestion();">Next &gt;</button>
                        </div>
                    `;
                }
            }

            function renderSideNav() {
                const navGrid = document.getElementById('questionGrid');
                navGrid.innerHTML = '';
                for (let i = 0; i < TOTAL_QUESTIONS; i++) {
                    const btn = document.createElement('button');
                    btn.className = `question-nav-btn ${userAnswers[i] !== null ? 'answered' : ''} ${i === currentQuestionIndex ? 'current' : ''}`;
                    btn.textContent = i + 1;
                    btn.onclick = () => { currentQuestionIndex = i; displayQuestion(); };
                    navGrid.appendChild(btn);
                }
            }

            function handleCheckAnswer() {
                const q = questions[currentQuestionIndex];
                if (gameState.difficulty === 'hell') {
                    // ‡∏™‡∏±‡πà‡∏á‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Layout ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ö‡∏ö‡∏¢‡πà‡∏≠
                    document.getElementById('choicesContainer').classList.add('hell-review-mode');
                    document.getElementById('practice-review-cube-area').classList.add('review-area-hell-compact');

                    // --- HELL MODE CHECK ---
                    // [‡πÅ‡∏Å‡πâ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ] ‡πÄ‡∏ï‡∏¥‡∏° []; ‡∏ï‡πà‡∏≠‡∏ó‡πâ‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏à‡∏ö‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏Ñ
                    const userChoiceIndices = userAnswers[currentQuestionIndex] || [];

                    const correctChoices = q.correctChoices || [];

                    // Convert choice objects to string keys for comparison
                    const correctChoiceKeys = new Set(correctChoices.map(c => [...c].sort().join('-')));
                    const allChoiceKeys = q.choices.map(c => [...c].sort().join('-'));

                    document.querySelectorAll('.choice-button').forEach((item, index) => {
                        item.classList.add('disabled');
                        const choiceKey = allChoiceKeys[index];
                        const isCorrectChoice = correctChoiceKeys.has(choiceKey);
                        const isUserSelected = userChoiceIndices.includes(index);

                        if (isCorrectChoice) {
                            item.classList.add('correct');
                        } else {
                            item.classList.add('incorrect'); // Mark all non-corrects
                        }
                        if (isUserSelected) {
                            item.classList.add('user-selected');
                            // (incorrect class is already applied if !isCorrectChoice)
                        }
                    });

                } else {
                    // --- Easy/Medium/Hard CHECK ---
                    const userAnswerIndex = userAnswers[currentQuestionIndex];
                    document.querySelectorAll('.choice-button').forEach((item, index) => {
                        item.classList.add('disabled');
                        const isCorrect = JSON.stringify(q.choices[index]) === JSON.stringify(q.correctChoice);
                        if (isCorrect) item.classList.add('correct');
                        if (index === userAnswerIndex) {
                            item.classList.add('user-selected');
                            if (!isCorrect) item.classList.add('incorrect');
                        }
                    });
                }
                // --- START: ADDED TO SHOW/POPULATE PRACTICE REVIEW CUBE ---
                if (gameState.mode === 'practice') {
                    populateInteractiveCube('practice-review-interactive-cube', q);
                    document.getElementById('practice-review-cube-area').classList.remove('hidden');
                }
                // --- START: ADDED TO SHOW/POPULATE PRACTICE REVIEW CUBE ---
                if (gameState.mode === 'practice') {
                    populateInteractiveCube('practice-review-interactive-cube', q);
                    document.getElementById('practice-review-cube-area').classList.remove('hidden');
                }
                // --- END: ADDED ---
                updateNavigation(); // Show "Next Question"
            }

            function startTimer() {
                // [FIX 3] ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå Timer ‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏¥‡πâ‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏™‡∏°‡∏≠ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Loop ‡∏ã‡πâ‡∏≠‡∏ô
                if (timerInterval) clearInterval(timerInterval);

                timeLeft = TIME_LIMIT;
                timerInterval = null;

                const timerEl = document.getElementById('headerTimer');
                timerEl.style.display = 'block';

                updateDisplay();
                timerInterval = setInterval(() => {
                    timeLeft--; // ‡∏•‡∏î‡∏Ñ‡πà‡∏≤‡∏•‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏ä‡πá‡∏Ñ
                    if (timeLeft < 0) {
                        clearInterval(timerInterval);
                        submitQuiz(true);
                    } else {
                        updateDisplay();
                    }
                }, 1000);

                function updateDisplay() {
                    const m = Math.floor(timeLeft / 60);
                    const s = timeLeft % 60;
                    timerEl.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
                    timerEl.classList.toggle('danger', timeLeft <= 30);
                }
            }
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏ã‡πà‡∏≠‡∏ô Timer ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏à‡∏ö‡πÄ‡∏Å‡∏° ‡∏´‡∏£‡∏∑‡∏≠‡∏Å‡∏î Back
            function hideTimer() {
                document.getElementById('headerTimer').style.display = 'none';
            }

            function submitQuiz(isTimeUp = false) {
                if (timerInterval) clearInterval(timerInterval);
                loader.style.display = 'flex';

                // --- 1. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÄ‡∏•‡∏¢ (‡∏¢‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡πÑ‡∏ß‡πâ‡∏ö‡∏ô‡∏™‡∏∏‡∏î) ---
                let correctCount = 0;
                userAnswers.forEach((userAnswer, qIndex) => {
                    if (userAnswer === null) return;
                    const q = questions[qIndex];
                    if (q.correctChoices) { // Hell Mode
                        const userChoiceIndices = userAnswer;
                        const correctChoices = q.correctChoices;
                        const correctChoiceKeys = new Set(correctChoices.map(c => [...c].sort().join('-')));
                        const userChoiceKeys = new Set(userChoiceIndices.map(i => [...q.choices[i]].sort().join('-')));
                        if (userChoiceKeys.size === correctChoiceKeys.size && [...userChoiceKeys].every(key => correctChoiceKeys.has(key))) {
                            correctCount++;
                        }
                    } else if (q.correctChoice) { // Normal Mode
                        if (JSON.stringify(q.choices[userAnswer]) === JSON.stringify(q.correctChoice)) {
                            correctCount++;
                        }
                    }
                });

                const answeredCount = userAnswers.filter(a => a !== null).length;
                const accuracy = answeredCount > 0 ? (correctCount / answeredCount) * 100 : 0;
                // ---------------------------------------------------------

                // --- START: MODIFIED FOR MOCKUP TEST ---
                if (isMockupMode) {
                    const scoreData = {
                        correctCount: correctCount,
                        totalQuestions: TOTAL_QUESTIONS,
                        answeredCount: answeredCount,
                        accuracy: parseFloat(accuracy.toFixed(2))
                    };
                    window.parent.postMessage({ type: 'testComplete', payload: { scoreData } }, '*');
                    loader.style.display = 'none';
                } else {
                    const timeUsed = gameState.mode === 'test' ? TIME_LIMIT - timeLeft : 0;

                    if (gameState.mode === 'test') {
                        // --- ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ Firebase ---
                        const scoreData = {
                            correctCount,
                            totalQuestions: TOTAL_QUESTIONS,
                            accuracy: parseFloat(accuracy.toFixed(2)),
                            timeUsed,
                            answeredCount,
                            difficulty: gameState.difficulty,
                            userEmail: currentUserEmail,
                            userAnswers: userAnswers
                        };

                        if (!currentUserEmail) {
                            alert("Error: User not authenticated. Please log in.");
                            loader.style.display = 'none';
                            return;
                        }

                        const SAVE_SCORE_URL = "https://us-central1-silp-pilot-platform.cloudfunctions.net/saveFoldingBoxScore";
                        const GET_BEST_SCORE_URL = "https://us-central1-silp-pilot-platform.cloudfunctions.net/getBestFoldingBoxScore";

                        fetch(SAVE_SCORE_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(scoreData)
                        })
                            .then(response => response.json())
                            .then(result => {
                                if (!result.success) { throw new Error(result.message || "Failed to save score."); }

                                const percentile = result.percentile ? `${result.percentile.toFixed(2)}%` : 'N/A';
                                showResults({ correctCount, accuracy, percentile, isTimeUp, timeUsed, answeredCount });

                                return fetch(`${GET_BEST_SCORE_URL}?email=${encodeURIComponent(currentUserEmail)}&difficulty=${gameState.difficulty}`);
                            })
                            .then(response => response.json())
                            .then(bestScoreResult => {
                                if (bestScoreResult.success) { onBestScoreReceived(bestScoreResult.data); }
                                else { onBestScoreReceived(null); }
                            })
                            .catch(err => {
                                console.error("Score save/fetch process failed:", err);
                                // ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ correctCount, accuracy, answeredCount ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô‡πÅ‡∏•‡πâ‡∏ß
                                showResults({ correctCount, accuracy, percentile: 'Error', isTimeUp, timeUsed, answeredCount });
                                onBestScoreReceived(null);
                                loader.style.display = 'none';
                            });

                    } else {
                        // Practice mode
                        setTimeout(() => {
                            showResults({ correctCount, accuracy });
                            loader.style.display = 'none';
                        }, 500);
                    }
                }
            }


            // --- END: MODIFIED FOR MOCKUP TEST ---

            function showResults({ correctCount, accuracy, percentile, isTimeUp = false, timeUsed = 0, answeredCount = 0 }) {
                switchScreen('results');
                // [FIX 3] ‡∏ã‡πà‡∏≠‡∏ô Timer ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                if (timerInterval) clearInterval(timerInterval);
                document.getElementById('headerTimer').style.display = 'none';
                switchScreen('results');

                document.getElementById('resultsTitle').textContent = isTimeUp ? "Time's Up!" : (gameState.mode === 'practice' ? "Practice Complete!" : "Quiz Results");
                if (gameState.mode === 'practice') {
                    document.getElementById('practiceResults').classList.remove('hidden');
                    document.getElementById('testResults').classList.add('hidden');
                    document.getElementById('reviewBtn').classList.add('hidden');
                    document.getElementById('practiceScore').textContent = `${correctCount} / ${TOTAL_QUESTIONS}`;
                    document.getElementById('practiceAccuracy').textContent = `${accuracy.toFixed(2)}%`;
                } else {
                    document.getElementById('practiceResults').classList.add('hidden');
                    document.getElementById('testResults').classList.remove('hidden');
                    document.getElementById('reviewBtn').classList.remove('hidden');
                    document.getElementById('currentScoreDisplay').textContent = `${correctCount} / ${TOTAL_QUESTIONS}`;
                    document.getElementById('currentAccuracyDisplay').textContent = `${accuracy.toFixed(2)}%`;
                    document.getElementById('avgTimeDisplay').textContent = `${answeredCount > 0 ? (timeUsed / answeredCount).toFixed(2) : 0}s`;
                    document.getElementById('currentPercentileDisplay').textContent = percentile;
                }
            }

            function onBestScoreReceived(data) {
                if (data && data.bestScore !== null) {
                    document.getElementById('bestScoreDisplay').textContent = `${data.bestScore} / ${data.totalQuestions}`;
                    document.getElementById('bestAccuracyDisplay').textContent = `${data.bestAccuracy.toFixed(2)}%`;
                    document.getElementById('bestPercentileDisplay').textContent = `${data.bestPercentile.toFixed(2)}%`;
                } else {
                    ['bestScoreDisplay', 'bestAccuracyDisplay', 'bestPercentileDisplay'].forEach(id => document.getElementById(id).textContent = 'N/A');
                }
                loader.style.display = 'none';
            }

            function showReview() {
                switchScreen('review');
                reviewQuestionIndex = 0;
                renderReviewQuestion();
            }

            function jumpToReviewQuestion(index) {
                if (index >= 0 && index < TOTAL_QUESTIONS) {
                    reviewQuestionIndex = index;
                    renderReviewQuestion();
                }
            }



            // --- IMPORTANT: Ensure getFaceHtmlWithRotation is Correctly Defined ---
            // Make sure this function exists *outside* of create3DCube, perhaps defined once before create3DCube.
            // Ensure it handles faceIndex -1 correctly (applies 0 rotation).

            function rotateCube(axis, direction, cubeId) { // <-- ADDED cubeIdfunction updateNavigation() {
                const rotationAmount = 90;
                const interactiveCube = document.getElementById(cubeId); // <-- MODIFIED
                if (!interactiveCube) return;

                if (axis === 'x') {
                    currentXRotation += rotationAmount * direction;
                } else if (axis === 'y') {
                    currentYRotation += rotationAmount * direction;
                } else if (axis === 'z') {
                    currentZRotation += rotationAmount * direction;
                }

                interactiveCube.style.transform = `rotateX(${currentXRotation}deg) rotateY(${currentYRotation}deg) rotateZ(${currentZRotation}deg)`;
            }

            function renderReviewNav() {
                const navGrid = document.getElementById('reviewNavGrid');
                navGrid.innerHTML = '';
                for (let i = 0; i < TOTAL_QUESTIONS; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'question-nav-btn';
                    btn.textContent = i + 1;
                    // --- START: MODIFIED FOR HELL MODE ---
                    let isCorrect = false;
                    const userAnswer = userAnswers[i];
                    const q = questions[i];

                    if (userAnswer !== null) {
                        if (q.correctChoices) { // Hell Mode
                            const userChoiceIndices = userAnswer || [];
                            const correctChoiceKeys = new Set(q.correctChoices.map(c => [...c].sort().join('-')));
                            const userChoiceKeys = new Set(userChoiceIndices.map(idx => [...q.choices[idx]].sort().join('-')));
                            isCorrect = (userChoiceKeys.size === correctChoiceKeys.size && [...userChoiceKeys].every(key => correctChoiceKeys.has(key)));
                        } else if (q.correctChoice) { // Easy/Medium/Hard
                            isCorrect = JSON.stringify(q.choices[userAnswer]) === JSON.stringify(q.correctChoice);
                        }
                    }
                    // --- END: MODIFIED FOR HELL MODE ---
                    if (i === reviewQuestionIndex) btn.classList.add('current');
                    btn.onclick = () => jumpToReviewQuestion(i);
                    navGrid.appendChild(btn);
                }
            }

            // =========================================
            // KEYBOARD SHORTCUTS & MAPPING (FINAL UPDATED)
            // =========================================
            document.addEventListener('keydown', (e) => {
                // 1. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡πà‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏´‡∏ô‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏ö‡πâ‡∏≤‡∏á
                const isStartActive = !document.getElementById('startScreen').classList.contains('hidden'); // [‡πÄ‡∏û‡∏¥‡πà‡∏°] ‡πÄ‡∏ä‡πá‡∏Ñ‡∏´‡∏ô‡πâ‡∏≤ Start
                const isGameActive = !document.getElementById('gameScreen').classList.contains('hidden');
                const isReviewActive = !document.getElementById('reviewScreen').classList.contains('hidden');
                const isResultsActive = !document.getElementById('resultsScreen').classList.contains('hidden');
                const isDifficultyActive = !document.getElementById('difficultyScreen').classList.contains('hidden');
                const isHowToPlayActive = !document.getElementById('howToPlayScreen').classList.contains('hidden');

                // --- ESCAPE KEY HANDLING (Global Back Function) ---
                if (e.key === 'Escape') {
                    e.preventDefault();

                    // 1. Modal Submit (‡πÉ‡∏ô‡πÄ‡∏Å‡∏°) -> ‡∏õ‡∏¥‡∏î Modal
                    const confirmModal = document.getElementById('confirmModal');
                    if (confirmModal.classList.contains('active')) {
                        document.getElementById('cancelSubmitBtn').click();
                        return;
                    }

                    // 2. ‡∏´‡∏ô‡πâ‡∏≤ Review Answer -> ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤ Results
                    if (isReviewActive) {
                        document.getElementById('backToResultsBtn').click();
                        return;
                    }

                    // 3. ‡∏´‡∏ô‡πâ‡∏≤ Practice Mode (Game Screen) -> ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Level
                    if (isGameActive && gameState.mode === 'practice') {
                        document.getElementById('backToMenuBtn').click();
                        return;
                    }

                    // 4. ‡∏´‡∏ô‡πâ‡∏≤ Results Screen -> ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤ Menu
                    if (isResultsActive) {
                        document.getElementById('retakeBtn').click();
                        return;
                    }

                    // 5. ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Difficulty -> ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤ Start Screen
                    if (isDifficultyActive) {
                        switchScreen('start');
                        return;
                    }

                    // 6. ‡∏´‡∏ô‡πâ‡∏≤ How to Play -> ‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤ Start
                    if (isHowToPlayActive) {
                        document.getElementById('backToStartBtn').click();
                        return;
                    }

                    // 7. [‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà] ‡∏´‡∏ô‡πâ‡∏≤ Start Screen -> ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏£‡∏∞‡∏ö‡∏ö (Back to Main Page)
                    if (isStartActive) {
                        // ‡∏™‡∏±‡πà‡∏á‡∏Ñ‡∏•‡∏¥‡∏Å‡∏õ‡∏∏‡πà‡∏° Back to Main Page
                        const backBtn = document.querySelector('#startScreen .back-to-system-btn');
                        if (backBtn) backBtn.click();
                        return;
                    }
                }

                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤ Game ‡∏´‡∏£‡∏∑‡∏≠ Review ‡∏Å‡πá‡∏à‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (‡∏õ‡∏∏‡πà‡∏°‡∏≠‡∏∑‡πà‡∏ô‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ)
                if (!isGameActive && !isReviewActive) return;


                // --- ‡∏™‡πà‡∏ß‡∏ô Modal Confirm (‡πÉ‡∏ä‡πâ Spacebar ‡∏´‡∏£‡∏∑‡∏≠ Enter) ---
                const confirmModal = document.getElementById('confirmModal');
                if (isGameActive && confirmModal.classList.contains('active')) {
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('confirmSubmitBtn').click();
                    }
                    return;
                }

                // --- 1. NAVIGATION (Left/Right Arrow) ---
                if (e.key === 'ArrowLeft') {
                    if (isGameActive && currentQuestionIndex > 0) {
                        currentQuestionIndex--;
                        displayQuestion();
                    } else if (isReviewActive && reviewQuestionIndex > 0) {
                        jumpToReviewQuestion(reviewQuestionIndex - 1);
                    }
                }
                else if (e.key === 'ArrowRight') {
                    if (isGameActive && currentQuestionIndex < TOTAL_QUESTIONS - 1) {
                        currentQuestionIndex++;
                        displayQuestion();
                    } else if (isReviewActive && reviewQuestionIndex < TOTAL_QUESTIONS - 1) {
                        jumpToReviewQuestion(reviewQuestionIndex + 1);
                    }
                }

                // --- 2. ACTION (Spacebar) ---
                if (e.key === ' ') {
                    e.preventDefault(); // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Scroll

                    if (isReviewActive) return; // Review ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏≠‡∏∞‡πÑ‡∏£

                    if (isGameActive) {
                        if (gameState.mode === 'practice') {
                            // Practice: Check / Next
                            const choicesContainer = document.getElementById('choicesContainer');
                            const isAnswered = choicesContainer.querySelector('.choice-button.correct') || choicesContainer.querySelector('.choice-button.incorrect');

                            if (isAnswered) {
                                if (currentQuestionIndex < TOTAL_QUESTIONS - 1) {
                                    currentQuestionIndex++;
                                    displayQuestion();
                                } else {
                                    submitQuiz();
                                }
                            } else {
                                if (userAnswers.hasOwnProperty(currentQuestionIndex)) {
                                    handleCheckAnswer();
                                }
                            }
                        } else {
                            // Test Mode: Open Modal
                            modal.classList.add('active');
                        }
                    }
                }

                // --- 3. CHOICE SELECTION (A-H or 1-8) ---
                if (isGameActive) {
                    const key = e.key.toUpperCase();
                    const keyMap = {
                        'A': 0, '1': 0, 'B': 1, '2': 1, 'C': 2, '3': 2, 'D': 3, '4': 3,
                        'E': 4, '5': 4, 'F': 5, '6': 5, 'G': 6, '7': 6, 'H': 7, '8': 7
                    };

                    if (keyMap.hasOwnProperty(key)) {
                        const choiceIndex = keyMap[key];
                        const q = questions[currentQuestionIndex];
                        if (q && q.choices && choiceIndex < q.choices.length) {
                            selectAnswer(choiceIndex);
                        }
                    }
                }
            });
        </script>
</body>
</html>